"""                                     Розширене ООП в Python


                        Класи контейнери


    Часто для роботи потрібно створити об'єкти, які поводяться як стандартні контейнери Python, але з модифікованою
поведінкою. Ви, звичайно, можете спробувати наслідувати dict, str, list, але це може призвести до ряду непередбачених 
помилок. Правильний спосіб отримати модифікований контейнер — це використовувати пакет collections та класи UserList, 
UserDict, UserString, які в ньому є.
    Всі ці класи поводяться точно як вбудовані контейнери з тією лише відмінністю, що самі дані лежать у полі data у цих 
класів і ви можете використовувати це поле на свій розсуд.
    UserDict — це клас, що міститься в модулі collections і слугує обгорткою навколо словника. Він дозволяє легше 
створювати власні класи словників, модифікуючи або додаючи нову поведінку до стандартних методів словника."""

from collections import UserDict

class MyDictionary(UserDict):
    # Приклад додавання нового методу
    def add_key(self, key, value):
        self.data[key] = value

# Створення екземпляра власного класу
my_dict = MyDictionary({'a': 1, 'b': 2})
my_dict.add_key('c', 3)
print(my_dict)

# Виведення:
# {'a': 1, 'b': 2, 'c': 3}
"""
    Ми створили клас MyDictionary, який наслідується від UserDict. Це надає всю стандартну функціональність словників, а також дозволяє легко модифікувати або розширювати її. Також ми додали метод add_key який демонструє, як можна додати нову поведінку для додавання елементів у словник.
Розглянемо більш корисний приклад. Ми маємо наступний список словників:

contacts = [
    {
        "name": "Allen Raymond",
        "email": "nulla.ante@vestibul.co.uk",
        "phone": "(992) 914-3792",
        "favorite": False,
    },
    {
        "name": "Chaim Lewis",
        "email": "dui.in@egetlacus.ca",
        "phone": "(294) 840-6685",
        "favorite": False,
    },
    {
        "name": "Kennedy Lane",
        "email": "mattis.Cras@nonenimMauris.net",
        "phone": "(542) 451-7038",
        "favorite": True,
    }
]
    Ми хотіли б мати можливість, щоб у словника були методи які нам показували ім'я-телефон, та ім'я-email
контакту. Для цього створимо клас Customer, який наслідує від UserDict з модуля collections.

class Customer(UserDict):
    def phone_info(self):
        return f"{self.get('name')}: {self.get('phone')}"

    def email_info(self):
        return f"{self.get('name')}: {self.get('email')}"

    Він розширює можливості UserDict та має два методи: phone_info і email_info, кожен з яких повертає рядок 
з ім'ям та телефонним номером або електронною адресою відповідного контакту.
    Щоб скористатися можливостями створеного класу нам необхідно створити новий список customers, в якому кожен 
елемент списку contacts перетворюється на екземпляр класу Customer. Це дозволить нам використовувати визначені в 
класі методи для кожного контакту.

customers = [Customer(el) for el in contacts]

Повний код прикладу виглядатиме так:"""

from collections import UserDict

contacts = [
    {
        "name": "Allen Raymond",
        "email": "nulla.ante@vestibul.co.uk",
        "phone": "(992) 914-3792",
        "favorite": False,
    },
    {
        "name": "Chaim Lewis",
        "email": "dui.in@egetlacus.ca",
        "phone": "(294) 840-6685",
        "favorite": False,
    },
    {
        "name": "Kennedy Lane",
        "email": "mattis.Cras@nonenimMauris.net",
        "phone": "(542) 451-7038",
        "favorite": True,
    }
]

class Customer(UserDict):
    def phone_info(self):
        return f"{self.get('name')}: {self.get('phone')}"

    def email_info(self):
        return f"{self.get('name')}: {self.get('email')}"

if __name__ == "__main__":
    customers = [Customer(el) for el in contacts]

    print("---------------------------")

    for customer in customers:
        print(customer.phone_info())

    print("---------------------------")

    for customer in customers:
        print(customer.email_info())

# Виведення:
# ---------------------------
# Allen Raymond: (992) 914-3792
# Chaim Lewis: (294) 840-6685
# Kennedy Lane: (542) 451-7038
# ---------------------------
# Allen Raymond: nulla.ante@vestibul.co.uk
# Chaim Lewis: dui.in@egetlacus.ca
# Kennedy Lane: mattis.Cras@nonenimMauris.net

"""    У цьому прикладі ми двічі виконуємо ітерації по списку customers: перший раз для виведення інформації 
про телефони контактів через виклик методу phone_info, а другий раз - для виведення інформації про електронні 
адреси через виклик методу email_info.
    UserList - це клас, який дозволяє створювати власні версії списків з додатковими функціями. Ви можете додавати 
нові методи або змінювати ті, що вже існують, щоб вони працювали по-іншому. Це корисно, коли вам потрібен список, 
який робить щось спеціальне, чого не робить звичайний список Python.
    Простий приклад використання UserList:"""

from collections import UserList

class MyList(UserList):
    # Додавання спеціалізованої поведінки. Наприклад, метод для додавання елемента, якщо він ще не існує
    def add_if_not_exists(self, item):
        if item not in self.data:
            self.data.append(item)

# Створення екземпляру MyList
my_list = MyList([1, 2, 3])
print("Оригінальний список:", my_list)

# Додавання елементу, якщо він не існує
my_list.add_if_not_exists(3)  # Не додасться, бо вже існує
my_list.add_if_not_exists(4)  # Додасться, бо ще не існує
print("Оновлений список:", my_list)

# Виведення:
# Оригінальний список: [1, 2, 3]
# Оновлений список: [1, 2, 3, 4]
"""
    У цьому прикладі, клас MyList наслідує від UserList і додає метод add_if_not_exists, який дозволяє 
додати елемент до списку, лише якщо він ще не існує у списку. При цьому в іншому my_list веде себе як 
звичайний список.
    Наступний приклад:"""

from collections import UserList

class CountableList(UserList):
    def sum(self):
        return sum(map(lambda x: int(x), self.data))

countable = CountableList([1, '2', 3, '4'])
countable.append('5')
print(countable.sum())

# Виведення:15
"""
    У цьому прикладі ми створили клас, який поводиться як список, але в ньому є метод sum , який повертає суму 
всього вмісту цього класу, при цьому перетворюючи рядки на цілі числа.
    Останнім розглянемо UserString який є класом, аналогічним до UserList, але для рядків. Він дозволяє створювати 
класи, які наслідують поведінку звичайного рядка, з можливістю додавання нових методів або зміни стандартної 
поведінки рядків. Це корисно, коли вам потрібно працювати з рядками спеціалізованим чином, який не підтримується 
стандартними рядками Python.
    Розглянемо наступний приклад:"""
from collections import UserString

# Створення класу, який розширює UserString
class MyString(UserString):
    # Додавання методу, який перевіряє, чи рядок є паліндромом
    def is_palindrome(self):
        return self.data == self.data[::-1]

# Створення екземпляру MyString
my_string = MyString("radar")
print("Рядок:", my_string)
print("Чи є паліндромом?", my_string.is_palindrome())

# Створення іншого екземпляру MyString
another_string = MyString("hello")
print("Рядок:", another_string)
print("Чи є паліндромом?", another_string.is_palindrome())

# Виведення:

# Рядок: radar
# Чи є паліндромом? True
# Рядок: hello
# Чи є паліндромом? False
"""
    У цьому прикладі, MyString наслідує від UserString і додає метод is_palindrome, який перевіряє, чи є 
рядок паліндромом (тобто читається однаково зліва направо та справа наліво).
    Останній приклад показує модифікований рядок з методом truncate, який обмежує розмір рядка до MAX_LEN символів."""

from collections import UserString

class TruncatedString(UserString):
    MAX_LEN = 7

    def truncate(self):
        self.data = self.data[:self.MAX_LEN]

ts = TruncatedString('hello world!')
ts.truncate()
print(ts)

# Виведення:
# hello w """

"""                 Класи даних

    Модуль dataclasses в Python надає засіб для декларативного визначення класів, які переважно використовуються 
для зберігання даних. Цей модуль введений у Python 3.7, щоб спростити створення таких класів без необхідності 
ручного написання бойлерплейт (від англ. - boilerplate) коду, який часто повторюється у традиційних класах.
    Модуль надає декоратор класу @dataclass який спрощує створення класів для зберігання даних. Традиційно, коли 
ми створюємо клас для зберігання даних, нам потрібно вручну визначити метод як-от __init__() для ініціалізації 
атрибутів, магічні методи для представлення об'єкта у зрозумілому форматі або для порівняння об'єктів. Декоратор 
@dataclass автоматизує цей процес, дозволяючи нам оголосити атрибути класу і автоматично генеруючи ці методи. 
Це робить код чистішим, менш вразливим до помилок і легшим для підтримки. З магічними методами ми детально 
познайомимося в наступному розділі.
        ☝ Використання @dataclass дозволяє зменшити кількість коду, необхідного для створення класів, які в основному 
        зберігають дані. Це робить код більш читабельним і легшим для розуміння, а також автоматично створює конструктор 
        класу __init__.
    Базовий приклад синтаксису @dataclass виглядає наступним чином:"""

from dataclasses import dataclass

@dataclass
class ExampleClass:
    attribute1: type
    attribute2: type = default_value

""" Традиційно, якщо вам потрібно створити клас для зберігання даних, ви б мали б вручну визначити метод __init__ для 
ініціалізації атрибутів."""

class Person:
    def __init__(self, name: str, age: int):
        self.name = name
        self.age = age

"""У цьому прикладі для створення простого класу Person, який зберігає ім'я та вік особи, ми визначили метод __init__ 
для ініціалізації атрибутів.
    Якщо використати декоратор @dataclass, ми можемо автоматизувати створення класу, значно спростивши код."""

from dataclasses import dataclass

@dataclass
class Person:
    name: str
    age: int

""" У цьому прикладі @dataclass автоматично генерує метод __init__ та інші магічні методи, на основі оголошених атрибутів. 
Ми отримуєте той самий функціонал, що й у попередньому прикладі, але з меншою кількістю коду та меншою ймовірністю помилок, 
пов'язаних з ручним визначенням методів.
    ☝ Перевага використання @dataclass полягає у тому, що він автоматизує багато рутинних задач, пов'язаних із створенням 
    класів, які зберігають дані.
    В наступному прикладі клас Article містить атрибути зі стандартними значеннями. Це корисно, коли деякі поля мають звичайні 
значення, які не вимагають вказівки при кожному створенні об'єкта:"""
@dataclass
class Article:
    title: str
    author: str
    views: int = 0

""" Розглянемо наступну задачу, щоб продемонструвати використання @dataclass у Python на конкретному прикладі. Ми створимо 
клас Rectangle, який буде обчислювати та виводити площу різних прямокутників, заданих користувачем."""

from dataclasses import dataclass

@dataclass
class Rectangle:
    width: int
    height: int

    def area(self) -> int:
        return self.width * self.height

rect1 = Rectangle(10, 5)
rect2 = Rectangle(7, 3)
rect3 = Rectangle(8, 6)

print(f"Площа прямокутника 1: {rect1.area()}")
print(f"Площа прямокутника 2: {rect2.area()}")
print(f"Площа прямокутника 3: {rect3.area()}")

""" Коли ми визначаємо клас Rectangle за допомогою @dataclass, Python автоматично створює метод __init__, який приймає 
атрибути width та height як параметри, за нас. Це означає, що нам не потрібно явно визначати конструктор класу."""

from dataclasses import dataclass

@dataclass
class Rectangle:
    width: int
    height: int

    def area(self) -> int:
        return self.width * self.height

# Тепер ми можемо створювати екземпляри класу Rectangle:

rect1 = Rectangle(10, 5)
rect2 = Rectangle(7, 3)
rect3 = Rectangle(8, 6)

# Кожен екземпляр класу Rectangle має метод area, який обчислює та повертає площу прямокутника, використовуючи 
# атрибути width та height.

print(f"Площа прямокутника 1: {rect1.area()}")
print(f"Площа прямокутника 2: {rect2.area()}")
print(f"Площа прямокутника 3: {rect3.area()}")

# Виведення:
# Площа прямокутника 1: 50
# Площа прямокутника 2: 21
# Площа прямокутника 3: 48

""" В підсумку ми бачимо, що декоратор @dataclass використовується, коли ви створюєте класи, що слугують для 
зберігання даних і не потребують складної логіки обробки. Наприклад, класи, що представляють сутності в базі д
аних, конфігураційні об'єкти, об'єкти передачі даних між компонентами системи тощо. 

                        Перелічуваний тип даних


    Перелічуваний тип даних (Enumeration), часто скорочено як Enum, - це спосіб визначення набору іменованих 
констант у мовах програмування, що дозволяє використовувати більш зрозумілі імена для цих констант замість 
простих числових значень. Enum визначає символічні імена для набору пов'язаних значень, полегшуючи читання та 
розуміння коду.
    Перелічення часто зустрічаються в ситуаціях, де потрібно представити обмежену кількість варіантів, таких як:
        - Дні тижня
        - Статуси замовлень (наприклад, "новий", "в обробці", "відправлений", "доставлений")
        - Ролі чи рівні доступу в системі безпеки (наприклад ролі, “користувач”, “модератор”, “адміністратор”)
    Використання Enum допомагає уникнути помилок, пов'язаних з використанням неправильних значень, і робить 
програмний код більш безпечним і легким для підтримки.
    Модуль enum в Python надає можливість для створення перелічуваних типів, які дозволяють визначати іменовані 
константи. Ці константи можуть бути використані для покращення читабельності та надійності коду, замінюючи використання 
неявних значень, таких як рядки або числа, на більш зрозумілі імена.
    Клас Enum з модуля enum дозволяє об'єднати ряд іменованих констант і гарантувати, що об'єкти цього класу 
можуть приймати тільки одне з обмежених значень, які вони описують.
    Для створення перелічення використовується наслідування від класу Enum. Кожен атрибут класу представляє 
окремий член перелічення."""

from enum import Enum

class Day(Enum):
    MONDAY = 1
    TUESDAY = 2
    WEDNESDAY = 3
    THURSDAY = 4
    FRIDAY = 5
    SATURDAY = 6
    SUNDAY = 7

""" Таке визначення дозволяє використовувати Day.MONDAY, Day.TUESDAY тощо, для представлення днів тижня у вашому 
коді, замість використання простих чисел або рядків.
    Ви можете отримати доступ до конкретного дня за допомогою його імені:"""

today = Day.MONDAY
print(today)  # Виведе: Day.MONDAY

# Enum члени можуть бути порівняні між собою за допомогою операторів порівняння:

if today == Day.MONDAY:
    print("Сьогодні понеділок.")
else:
    print("Сьогодні не понеділок.")

# Виведення:
# Сьогодні понеділок.

# Кожен член Enum має властивості name і value, які повертають ім'я та значення члена відповідно:

print(today.name)  
print(today.value)  

# Виведення:
# MONDAY
# 1

# Якщо у вас є значення і ви хочете отримати відповідний член Enum, ви можете використовувати метод Day() з цим значенням:

day_from_value = Day(1)
print(day_from_value)  # Виведе: Day.MONDAY

""" Давайте розглянемо наближений до реальності приклад використання Enum, де ми створимо систему управління статусами 
замовлень для інтернет-магазину. У цьому прикладі, Enum використовується для створення чітко визначеного набору статусів, 
які може мати замовлення. Ці статуси включають "Новий" (NEW), "В обробці" (PROCESSING), "Відправлено" (SHIPPED), та 
"Доставлено" (DELIVERED).
    Перш за все, нам потрібно визначити Enum, який буде представляти різні статуси замовлень.

from enum import Enum, auto

class OrderStatus(Enum):
    NEW = auto()
    PROCESSING = auto()
    SHIPPED = auto()
    DELIVERED = auto()

# Тут ми використали функцію auto(), щоб автоматично присвоїти унікальні значення кожному статусу, 
# уникаючи необхідності вручну вказувати їх.
# Тепер створимо клас Order, який буде використовувати наш перелічуваний тип даних OrderStatus для 
# відстеження статусу замовлення.

class Order:
    def __init__(self, name: str, status: OrderStatus):
        self.name = name
        self.status = status

    def update_status(self, new_status: OrderStatus):
        self.status = new_status
        print(f"Замовлення '{self.name}' оновлено до статусу {self.status.name}.")

    def display_status(self):
        print(f"Статус замовлення '{self.name}': {self.status.name}.")

# Тепер створимо декілька замовлень і покажемо, як можна оновити та відобразити їх статуси.


order1 = Order("Ноутбук", OrderStatus.NEW)
order2 = Order("Книга", OrderStatus.NEW)

order1.display_status()
order2.display_status()

order1.update_status(OrderStatus.PROCESSING)
order2.update_status(OrderStatus.SHIPPED)

order1.display_status()
order2.display_status()

Повний код буде виглядати наступним чином:"""

from enum import Enum, auto

class OrderStatus(Enum):
    NEW = auto()
    PROCESSING = auto()
    SHIPPED = auto()
    DELIVERED = auto()

class Order:
    def __init__(self, name: str, status: OrderStatus):
        self.name = name
        self.status = status

    def update_status(self, new_status: OrderStatus):
        self.status = new_status
        print(f"Замовлення '{self.name}' оновлено до статусу {self.status.name}.")

    def display_status(self):
        print(f"Статус замовлення '{self.name}': {self.status.name}.")

order1 = Order("Ноутбук", OrderStatus.NEW)
order2 = Order("Книга", OrderStatus.NEW)

order1.display_status()
order2.display_status()

order1.update_status(OrderStatus.PROCESSING)
order2.update_status(OrderStatus.SHIPPED)

order1.display_status()
order2.display_status()

""" Коли ми виконаємо цей код, ми побачимо, як статуси замовлень оновлюються та відображаються:

Статус замовлення 'Ноутбук': NEW.
Статус замовлення 'Книга': NEW.
Замовлення 'Ноутбук' оновлено до статусу PROCESSING.
Замовлення 'Книга' оновлено до статусу SHIPPED.
Статус замовлення 'Ноутбук': PROCESSING.
Статус замовлення 'Книга': SHIPPED.

    Приклад демонструє, як Enum може бути використаний для ефективного представлення та управління фіксованим 
набором можливих станів в програмі. 
    Це забезпечує чітке визначення статусів замовлень і допомагає запобігти помилкам, пов'язаним з використанням 
неправильних або невідомих статусів.
    В підсумку ми бачимо, що використання перелічень робить код більш читабельним, оскільки вони дозволяють 
використовувати іменовані константи замість магічних чисел або рядків. Оскільки об'єкт Enum може приймати лише 
значення, визначені в переліку, це зменшує ймовірність помилок, пов'язаних з передачею невірних значень.
    Зміна або додавання нових значень в Enum не впливає на решту коду, що робить зміну (рефакторінг) та розширення 
коду простішими. Наприклад, щоб додати новий статус "Відмінений"(CANCELED), ви просто розширите визначення 
OrderStatus таким чином:"""

from enum import Enum, auto

class OrderStatus(Enum):
    NEW = auto()
    PROCESSING = auto()
    SHIPPED = auto()
    DELIVERED = auto()
    CANCELED = auto()

# Ніяк не міняючи інший код в програмі, що вже існує.


