"""                                     Розширене ООП в Python


                        Класи контейнери


    Часто для роботи потрібно створити об'єкти, які поводяться як стандартні контейнери Python, але з модифікованою
поведінкою. Ви, звичайно, можете спробувати наслідувати dict, str, list, але це може призвести до ряду непередбачених 
помилок. Правильний спосіб отримати модифікований контейнер — це використовувати пакет collections та класи UserList, 
UserDict, UserString, які в ньому є.
    Всі ці класи поводяться точно як вбудовані контейнери з тією лише відмінністю, що самі дані лежать у полі data у цих 
класів і ви можете використовувати це поле на свій розсуд.
    UserDict — це клас, що міститься в модулі collections і слугує обгорткою навколо словника. Він дозволяє легше 
створювати власні класи словників, модифікуючи або додаючи нову поведінку до стандартних методів словника."""

from collections import UserDict

class MyDictionary(UserDict):
    # Приклад додавання нового методу
    def add_key(self, key, value):
        self.data[key] = value

# Створення екземпляра власного класу
my_dict = MyDictionary({'a': 1, 'b': 2})
my_dict.add_key('c', 3)
print(my_dict)

# Виведення:
# {'a': 1, 'b': 2, 'c': 3}
"""
    Ми створили клас MyDictionary, який наслідується від UserDict. Це надає всю стандартну функціональність словників, а також дозволяє легко модифікувати або розширювати її. Також ми додали метод add_key який демонструє, як можна додати нову поведінку для додавання елементів у словник.
Розглянемо більш корисний приклад. Ми маємо наступний список словників:

contacts = [
    {
        "name": "Allen Raymond",
        "email": "nulla.ante@vestibul.co.uk",
        "phone": "(992) 914-3792",
        "favorite": False,
    },
    {
        "name": "Chaim Lewis",
        "email": "dui.in@egetlacus.ca",
        "phone": "(294) 840-6685",
        "favorite": False,
    },
    {
        "name": "Kennedy Lane",
        "email": "mattis.Cras@nonenimMauris.net",
        "phone": "(542) 451-7038",
        "favorite": True,
    }
]
    Ми хотіли б мати можливість, щоб у словника були методи які нам показували ім'я-телефон, та ім'я-email
контакту. Для цього створимо клас Customer, який наслідує від UserDict з модуля collections.

class Customer(UserDict):
    def phone_info(self):
        return f"{self.get('name')}: {self.get('phone')}"

    def email_info(self):
        return f"{self.get('name')}: {self.get('email')}"

    Він розширює можливості UserDict та має два методи: phone_info і email_info, кожен з яких повертає рядок 
з ім'ям та телефонним номером або електронною адресою відповідного контакту.
    Щоб скористатися можливостями створеного класу нам необхідно створити новий список customers, в якому кожен 
елемент списку contacts перетворюється на екземпляр класу Customer. Це дозволить нам використовувати визначені в 
класі методи для кожного контакту.

customers = [Customer(el) for el in contacts]

Повний код прикладу виглядатиме так:"""

from collections import UserDict

contacts = [
    {
        "name": "Allen Raymond",
        "email": "nulla.ante@vestibul.co.uk",
        "phone": "(992) 914-3792",
        "favorite": False,
    },
    {
        "name": "Chaim Lewis",
        "email": "dui.in@egetlacus.ca",
        "phone": "(294) 840-6685",
        "favorite": False,
    },
    {
        "name": "Kennedy Lane",
        "email": "mattis.Cras@nonenimMauris.net",
        "phone": "(542) 451-7038",
        "favorite": True,
    }
]

class Customer(UserDict):
    def phone_info(self):
        return f"{self.get('name')}: {self.get('phone')}"

    def email_info(self):
        return f"{self.get('name')}: {self.get('email')}"

if __name__ == "__main__":
    customers = [Customer(el) for el in contacts]

    print("---------------------------")

    for customer in customers:
        print(customer.phone_info())

    print("---------------------------")

    for customer in customers:
        print(customer.email_info())

# Виведення:
# ---------------------------
# Allen Raymond: (992) 914-3792
# Chaim Lewis: (294) 840-6685
# Kennedy Lane: (542) 451-7038
# ---------------------------
# Allen Raymond: nulla.ante@vestibul.co.uk
# Chaim Lewis: dui.in@egetlacus.ca
# Kennedy Lane: mattis.Cras@nonenimMauris.net

"""    У цьому прикладі ми двічі виконуємо ітерації по списку customers: перший раз для виведення інформації 
про телефони контактів через виклик методу phone_info, а другий раз - для виведення інформації про електронні 
адреси через виклик методу email_info.
    UserList - це клас, який дозволяє створювати власні версії списків з додатковими функціями. Ви можете додавати 
нові методи або змінювати ті, що вже існують, щоб вони працювали по-іншому. Це корисно, коли вам потрібен список, 
який робить щось спеціальне, чого не робить звичайний список Python.
    Простий приклад використання UserList:"""

from collections import UserList

class MyList(UserList):
    # Додавання спеціалізованої поведінки. Наприклад, метод для додавання елемента, якщо він ще не існує
    def add_if_not_exists(self, item):
        if item not in self.data:
            self.data.append(item)

# Створення екземпляру MyList
my_list = MyList([1, 2, 3])
print("Оригінальний список:", my_list)

# Додавання елементу, якщо він не існує
my_list.add_if_not_exists(3)  # Не додасться, бо вже існує
my_list.add_if_not_exists(4)  # Додасться, бо ще не існує
print("Оновлений список:", my_list)

# Виведення:
# Оригінальний список: [1, 2, 3]
# Оновлений список: [1, 2, 3, 4]
"""
    У цьому прикладі, клас MyList наслідує від UserList і додає метод add_if_not_exists, який дозволяє 
додати елемент до списку, лише якщо він ще не існує у списку. При цьому в іншому my_list веде себе як 
звичайний список.
    Наступний приклад:"""

from collections import UserList

class CountableList(UserList):
    def sum(self):
        return sum(map(lambda x: int(x), self.data))

countable = CountableList([1, '2', 3, '4'])
countable.append('5')
print(countable.sum())

# Виведення:15
"""
    У цьому прикладі ми створили клас, який поводиться як список, але в ньому є метод sum , який повертає суму 
всього вмісту цього класу, при цьому перетворюючи рядки на цілі числа.
    Останнім розглянемо UserString який є класом, аналогічним до UserList, але для рядків. Він дозволяє створювати 
класи, які наслідують поведінку звичайного рядка, з можливістю додавання нових методів або зміни стандартної 
поведінки рядків. Це корисно, коли вам потрібно працювати з рядками спеціалізованим чином, який не підтримується 
стандартними рядками Python.
    Розглянемо наступний приклад:"""
from collections import UserString

# Створення класу, який розширює UserString
class MyString(UserString):
    # Додавання методу, який перевіряє, чи рядок є паліндромом
    def is_palindrome(self):
        return self.data == self.data[::-1]

# Створення екземпляру MyString
my_string = MyString("radar")
print("Рядок:", my_string)
print("Чи є паліндромом?", my_string.is_palindrome())

# Створення іншого екземпляру MyString
another_string = MyString("hello")
print("Рядок:", another_string)
print("Чи є паліндромом?", another_string.is_palindrome())

# Виведення:

# Рядок: radar
# Чи є паліндромом? True
# Рядок: hello
# Чи є паліндромом? False
"""
    У цьому прикладі, MyString наслідує від UserString і додає метод is_palindrome, який перевіряє, чи є 
рядок паліндромом (тобто читається однаково зліва направо та справа наліво).
    Останній приклад показує модифікований рядок з методом truncate, який обмежує розмір рядка до MAX_LEN символів."""

from collections import UserString

class TruncatedString(UserString):
    MAX_LEN = 7

    def truncate(self):
        self.data = self.data[:self.MAX_LEN]

ts = TruncatedString('hello world!')
ts.truncate()
print(ts)

# Виведення:
# hello w """

"""                 Класи даних

    Модуль dataclasses в Python надає засіб для декларативного визначення класів, які переважно використовуються 
для зберігання даних. Цей модуль введений у Python 3.7, щоб спростити створення таких класів без необхідності 
ручного написання бойлерплейт (від англ. - boilerplate) коду, який часто повторюється у традиційних класах.
    Модуль надає декоратор класу @dataclass який спрощує створення класів для зберігання даних. Традиційно, коли 
ми створюємо клас для зберігання даних, нам потрібно вручну визначити метод як-от __init__() для ініціалізації 
атрибутів, магічні методи для представлення об'єкта у зрозумілому форматі або для порівняння об'єктів. Декоратор 
@dataclass автоматизує цей процес, дозволяючи нам оголосити атрибути класу і автоматично генеруючи ці методи. 
Це робить код чистішим, менш вразливим до помилок і легшим для підтримки. З магічними методами ми детально 
познайомимося в наступному розділі.
        ☝ Використання @dataclass дозволяє зменшити кількість коду, необхідного для створення класів, які в основному 
        зберігають дані. Це робить код більш читабельним і легшим для розуміння, а також автоматично створює конструктор 
        класу __init__.
    Базовий приклад синтаксису @dataclass виглядає наступним чином:"""

# from dataclasses import dataclass

# @dataclass
# class ExampleClass:
#     attribute1: type
#     attribute2: type = default_value

""" Традиційно, якщо вам потрібно створити клас для зберігання даних, ви б мали б вручну визначити метод __init__ для 
ініціалізації атрибутів."""

class Person:
    def __init__(self, name: str, age: int):
        self.name = name
        self.age = age

"""У цьому прикладі для створення простого класу Person, який зберігає ім'я та вік особи, ми визначили метод __init__ 
для ініціалізації атрибутів.
    Якщо використати декоратор @dataclass, ми можемо автоматизувати створення класу, значно спростивши код."""

from dataclasses import dataclass

@dataclass
class Person:
    name: str
    age: int

""" У цьому прикладі @dataclass автоматично генерує метод __init__ та інші магічні методи, на основі оголошених атрибутів. 
Ми отримуєте той самий функціонал, що й у попередньому прикладі, але з меншою кількістю коду та меншою ймовірністю помилок, 
пов'язаних з ручним визначенням методів.
    ☝ Перевага використання @dataclass полягає у тому, що він автоматизує багато рутинних задач, пов'язаних із створенням 
    класів, які зберігають дані.
    В наступному прикладі клас Article містить атрибути зі стандартними значеннями. Це корисно, коли деякі поля мають звичайні 
значення, які не вимагають вказівки при кожному створенні об'єкта:"""
@dataclass
class Article:
    title: str
    author: str
    views: int = 0

""" Розглянемо наступну задачу, щоб продемонструвати використання @dataclass у Python на конкретному прикладі. Ми створимо 
клас Rectangle, який буде обчислювати та виводити площу різних прямокутників, заданих користувачем."""

from dataclasses import dataclass

@dataclass
class Rectangle:
    width: int
    height: int

    def area(self) -> int:
        return self.width * self.height

rect1 = Rectangle(10, 5)
rect2 = Rectangle(7, 3)
rect3 = Rectangle(8, 6)

print(f"Площа прямокутника 1: {rect1.area()}")
print(f"Площа прямокутника 2: {rect2.area()}")
print(f"Площа прямокутника 3: {rect3.area()}")

""" Коли ми визначаємо клас Rectangle за допомогою @dataclass, Python автоматично створює метод __init__, який приймає 
атрибути width та height як параметри, за нас. Це означає, що нам не потрібно явно визначати конструктор класу."""

from dataclasses import dataclass

@dataclass
class Rectangle:
    width: int
    height: int

    def area(self) -> int:
        return self.width * self.height

# Тепер ми можемо створювати екземпляри класу Rectangle:

rect1 = Rectangle(10, 5)
rect2 = Rectangle(7, 3)
rect3 = Rectangle(8, 6)

# Кожен екземпляр класу Rectangle має метод area, який обчислює та повертає площу прямокутника, використовуючи 
# атрибути width та height.

print(f"Площа прямокутника 1: {rect1.area()}")
print(f"Площа прямокутника 2: {rect2.area()}")
print(f"Площа прямокутника 3: {rect3.area()}")

# Виведення:
# Площа прямокутника 1: 50
# Площа прямокутника 2: 21
# Площа прямокутника 3: 48

""" В підсумку ми бачимо, що декоратор @dataclass використовується, коли ви створюєте класи, що слугують для 
зберігання даних і не потребують складної логіки обробки. Наприклад, класи, що представляють сутності в базі д
аних, конфігураційні об'єкти, об'єкти передачі даних між компонентами системи тощо. 

                        Перелічуваний тип даних


    Перелічуваний тип даних (Enumeration), часто скорочено як Enum, - це спосіб визначення набору іменованих 
констант у мовах програмування, що дозволяє використовувати більш зрозумілі імена для цих констант замість 
простих числових значень. Enum визначає символічні імена для набору пов'язаних значень, полегшуючи читання та 
розуміння коду.
    Перелічення часто зустрічаються в ситуаціях, де потрібно представити обмежену кількість варіантів, таких як:
        - Дні тижня
        - Статуси замовлень (наприклад, "новий", "в обробці", "відправлений", "доставлений")
        - Ролі чи рівні доступу в системі безпеки (наприклад ролі, “користувач”, “модератор”, “адміністратор”)
    Використання Enum допомагає уникнути помилок, пов'язаних з використанням неправильних значень, і робить 
програмний код більш безпечним і легким для підтримки.
    Модуль enum в Python надає можливість для створення перелічуваних типів, які дозволяють визначати іменовані 
константи. Ці константи можуть бути використані для покращення читабельності та надійності коду, замінюючи використання 
неявних значень, таких як рядки або числа, на більш зрозумілі імена.
    Клас Enum з модуля enum дозволяє об'єднати ряд іменованих констант і гарантувати, що об'єкти цього класу 
можуть приймати тільки одне з обмежених значень, які вони описують.
    Для створення перелічення використовується наслідування від класу Enum. Кожен атрибут класу представляє 
окремий член перелічення."""

from enum import Enum

class Day(Enum):
    MONDAY = 1
    TUESDAY = 2
    WEDNESDAY = 3
    THURSDAY = 4
    FRIDAY = 5
    SATURDAY = 6
    SUNDAY = 7

""" Таке визначення дозволяє використовувати Day.MONDAY, Day.TUESDAY тощо, для представлення днів тижня у вашому 
коді, замість використання простих чисел або рядків.
    Ви можете отримати доступ до конкретного дня за допомогою його імені:"""

today = Day.MONDAY
print(today)  # Виведе: Day.MONDAY

# Enum члени можуть бути порівняні між собою за допомогою операторів порівняння:

if today == Day.MONDAY:
    print("Сьогодні понеділок.")
else:
    print("Сьогодні не понеділок.")

# Виведення:
# Сьогодні понеділок.

# Кожен член Enum має властивості name і value, які повертають ім'я та значення члена відповідно:

print(today.name)  
print(today.value)  

# Виведення:
# MONDAY
# 1

# Якщо у вас є значення і ви хочете отримати відповідний член Enum, ви можете використовувати метод Day() з цим значенням:

day_from_value = Day(1)
print(day_from_value)  # Виведе: Day.MONDAY

""" Давайте розглянемо наближений до реальності приклад використання Enum, де ми створимо систему управління статусами 
замовлень для інтернет-магазину. У цьому прикладі, Enum використовується для створення чітко визначеного набору статусів, 
які може мати замовлення. Ці статуси включають "Новий" (NEW), "В обробці" (PROCESSING), "Відправлено" (SHIPPED), та 
"Доставлено" (DELIVERED).
    Перш за все, нам потрібно визначити Enum, який буде представляти різні статуси замовлень.

from enum import Enum, auto

class OrderStatus(Enum):
    NEW = auto()
    PROCESSING = auto()
    SHIPPED = auto()
    DELIVERED = auto()

# Тут ми використали функцію auto(), щоб автоматично присвоїти унікальні значення кожному статусу, 
# уникаючи необхідності вручну вказувати їх.
# Тепер створимо клас Order, який буде використовувати наш перелічуваний тип даних OrderStatus для 
# відстеження статусу замовлення.

class Order:
    def __init__(self, name: str, status: OrderStatus):
        self.name = name
        self.status = status

    def update_status(self, new_status: OrderStatus):
        self.status = new_status
        print(f"Замовлення '{self.name}' оновлено до статусу {self.status.name}.")

    def display_status(self):
        print(f"Статус замовлення '{self.name}': {self.status.name}.")

# Тепер створимо декілька замовлень і покажемо, як можна оновити та відобразити їх статуси.


order1 = Order("Ноутбук", OrderStatus.NEW)
order2 = Order("Книга", OrderStatus.NEW)

order1.display_status()
order2.display_status()

order1.update_status(OrderStatus.PROCESSING)
order2.update_status(OrderStatus.SHIPPED)

order1.display_status()
order2.display_status()

Повний код буде виглядати наступним чином:"""

from enum import Enum, auto

class OrderStatus(Enum):
    NEW = auto()
    PROCESSING = auto()
    SHIPPED = auto()
    DELIVERED = auto()

class Order:
    def __init__(self, name: str, status: OrderStatus):
        self.name = name
        self.status = status

    def update_status(self, new_status: OrderStatus):
        self.status = new_status
        print(f"Замовлення '{self.name}' оновлено до статусу {self.status.name}.")

    def display_status(self):
        print(f"Статус замовлення '{self.name}': {self.status.name}.")

order1 = Order("Ноутбук", OrderStatus.NEW)
order2 = Order("Книга", OrderStatus.NEW)

order1.display_status()
order2.display_status()

order1.update_status(OrderStatus.PROCESSING)
order2.update_status(OrderStatus.SHIPPED)

order1.display_status()
order2.display_status()

""" Коли ми виконаємо цей код, ми побачимо, як статуси замовлень оновлюються та відображаються:

Статус замовлення 'Ноутбук': NEW.
Статус замовлення 'Книга': NEW.
Замовлення 'Ноутбук' оновлено до статусу PROCESSING.
Замовлення 'Книга' оновлено до статусу SHIPPED.
Статус замовлення 'Ноутбук': PROCESSING.
Статус замовлення 'Книга': SHIPPED.

    Приклад демонструє, як Enum може бути використаний для ефективного представлення та управління фіксованим 
набором можливих станів в програмі. 
    Це забезпечує чітке визначення статусів замовлень і допомагає запобігти помилкам, пов'язаним з використанням 
неправильних або невідомих статусів.
    В підсумку ми бачимо, що використання перелічень робить код більш читабельним, оскільки вони дозволяють 
використовувати іменовані константи замість магічних чисел або рядків. Оскільки об'єкт Enum може приймати лише 
значення, визначені в переліку, це зменшує ймовірність помилок, пов'язаних з передачею невірних значень.
    Зміна або додавання нових значень в Enum не впливає на решту коду, що робить зміну (рефакторінг) та розширення 
коду простішими. Наприклад, щоб додати новий статус "Відмінений"(CANCELED), ви просто розширите визначення 
OrderStatus таким чином:"""

from enum import Enum, auto

class OrderStatus(Enum):
    NEW = auto()
    PROCESSING = auto()
    SHIPPED = auto()
    DELIVERED = auto()
    CANCELED = auto()

# Ніяк не міняючи інший код в програмі, що вже існує.

"""                     Асоціація, композиція та агрегація в ООП

    Просте наслідування в ООП дозволяє класу наслідувати поведінку та властивості іншого класу. Хоча це потужний 
інструмент для уникнення дублювання коду, він має певні обмеження. Наслідування створює тісну залежність між базовим 
класом та похідними класами. Зміни в базовому класі можуть несподівано вплинути на поведінку похідних класів. 
Наслідування може призвести до спадкування методів, які не мають сенсу для похідного класу, що може призвести до 
неочікуваної або помилкової поведінки.
    Асоціація пропонує альтернативу наслідуванню, яка може уникнути деяких його недоліків. Асоціація в ООП - це 
концепція, яка описує відносини між класами через їх об'єкти. У цьому контексті, клас може включати в себе інший клас 
як одне зі своїх полів, що описується словом "має".
    Асоціація поділяється на два основних типи: композиція та агрегація, кожен з яких має свої особливості та застосування.
    Агрегація - це тип відношення між об'єктами, яке також представляє відносини "ціле" до "частини", але в цьому випадку 
"частини" можуть існувати незалежно від "цілого". Це означає, що якщо "ціле" буде знищено, "частини" можуть продовжувати 
існувати самостійно. Агрегація вказує на більш слабку залежність між об'єктами і часто використовується, коли об'єкти 
можуть входити до складу різних груп або колекцій. Наприклад, бібліотека (ціле) може містити книги (частини) через 
агрегацію; якщо бібліотека закриється, книги все одно залишаться і можуть бути переміщені до іншої бібліотеки.
    Розглянемо приклад, який ілюструє, чому наслідування не є найкращим рішенням, і як асоціація між цими класами через 
агрегацію є більш відповідним підходом.
    Спочатку розглянемо ситуацію, де ми могли б неправильно вирішити використати наслідування. Маємо клас Owner для 
господаря кішки та клас Cat для самої кішки."""

class Owner:
    def __init__(self, name, phone):
        self.name = name
        self.phone = phone

    def info(self):
        return f"{self.name}: {self.phone}"

class Cat(Owner):
    def __init__(self, nickname, age, name, phone):
        super().__init__(name, phone)
        self.nickname = nickname
        self.age = age

    def cat_info(self):
        return f"Cat Name: {self.nickname}, Age: {self.age}"

		def sound(self):
		        return "Meow"

cat = Cat('Simon', 4, 'Boris', '+380503002010')
print(cat.info())
print(cat.cat_info())

# Виведення:
# Boris: +380503002010
# Cat Name: Simon, Age: 4
"""
    Може здатися, що це добра ідея зробити кішку "частиною" господаря, використовуючи наслідування. Це б виглядало 
так, ніби ми кажемо: "Кішка є господарем". Але це не має сенсу, правда? Кішка і господар - це дві різні речі.
    Кішка не може бути господарем. Вона просто має господаря.
    Натомість, ми повинні показати, що кішка "має" господаря. Це не робить кішку господарем. Просто означає, що між 
кішкою та людиною є зв'язок. Людина - це господар кішки, а кішка - це вихованець цієї людини."""
class Owner:
    def __init__(self, name: str, phone: str):
        self.name = name
        self.phone = phone

    def info(self):
        return f"{self.name}: {self.phone}"

class Cat:
    def __init__(self, nickname: str, age: int, owner: Owner):
        self.nickname = nickname
        self.age = age
        self.owner = owner

    def get_info(self):
        return f"Cat Name: {self.nickname}, Age: {self.age}"

    def sound(self):
        return "Meow"

owner = Owner("Boris", "+380503002010")
cat = Cat("Simon", 4, owner)

print(cat.owner.info())
print(cat.get_info())

# Виведення:
# Boris: +380503002010
# Cat Name: Simon, Age: 4
""" У цьому прикладі, Cat та Owner асоційовані через агрегацію, де Cat має посилання на Owner, але об'єкти Owner 
можуть існувати незалежно від Cat. Тут ми кажемо: "Кішка має господаря", що є більш логічним і правильним з точки 
зору нашої програми. Це відображає реальні відносини між кішками та їх господарями більш точно та дозволяє кішкам 
мати або не мати господаря без порушення логіки.

    ☝ Агрегація дозволяє "частині" існувати незалежно від "цілого". У нашому прикладі, це означає, що господар може 
    існувати окремо від улюбленця. Екземпляр господаря створюється незалежно і лише потім асоціюється з твариною, 
    передаючись в конструктор вихованця як параметр.

    Композиція - це тип відношення між об'єктами, де один об'єкт є частиною іншого. У відношенні композиції "частина" 
не може існувати без "цілого". Це означає, що якщо "ціле" буде знищено або видалено, то "частина" також буде знищена 
або видалена.
    Композиція ефективно використовується в ситуаціях, де об'єкти мають сильну залежність один від одного, і "частина" 
не може існувати без "цілого". Тобто, якщо один об'єкт володіє іншим об'єктом і відповідальний за його життєвий цикл, 
то між ними існує відношення композиції.
    Уявімо, що ми розробляємо програмне забезпечення для управління проектами. У цій системі кожен "Проект" (клас Project), 
може містити кілька "Задач" (клас Task), і ці задачі не мають сенсу поза контекстом свого проекту. Якщо проект видаляється, 
то всі його задачі також повинні бути видалені.
Розглянемо реалізацію"""
class Task:
    def __init__(self, name: str, description: str):
        self.name = name
        self.description = description

    def display_info(self):
        print(f"Задача: {self.name}, Опис: {self.description}")

class Project:
    def __init__(self, name: str):
        self.name = name
        self.tasks: list(Task) = []

    def add_task(self, name: str, description: str):
        self.tasks.append(Task(name, description))

    def remove_task(self, name: str):
        self.tasks = [task for task in self.tasks if task.name != name]

    def display_project_info(self):
        print(f"Проект: {self.name}")
        for task in self.tasks:
            task.display_info()

# Створення проекту
my_project = Project("Веб-розробка")

# Додавання задач
my_project.add_task("Дизайн інтерфейсу", "Створити макет головної сторінки.")
my_project.add_task("Розробка API", "Реалізувати ендпоінти для користувачів.")

# Відображення інформації про проект
my_project.display_project_info()

# Видалення задачі
my_project.remove_task("Розробка API")

# Перевірка видалення задачі
my_project.display_project_info()

# Виведення:
# Проект: Веб-розробка
# Задача: Дизайн інтерфейсу, Опис: Створити макет головної сторінки. 
# Задача: Розробка API, Опис: Реалізувати ендпоінти для користувачів.
# Проект: Веб-розробка
# Задача: Дизайн інтерфейсу, Опис: Створити макет головної сторінки.

""" У цьому прикладі, клас Project включає в себе об'єкти класу Task як "частини" проекту. Задачі створюються та 
керуються виключно через проект, що є яскравим прикладом композиції. Але чому тут підходить композиція? Життєвий 
цикл об'єктів Task тісно пов'язаний з життєвим циклом об'єкта Project. Задачі не можуть існувати без проекту. 
Клас Project "володіє" своїми Task. Це означає, що видалення проекту автоматично призведе до видалення всіх його задач.
    Композиція дозволяє інкапсулювати поведінку та дані, пов'язані з управлінням задачами, всередині класу Project, 
що робить систему більш організованою та зрозумілою.

    ☝ Композиція є ідеальним вибором для моделювання відносин, де існує сильна залежність між об'єктами, і "частини" 
    не можуть існувати самостійно без "цілого". Вона забезпечує чітку структуру володіння та керування об'єктами, 
    підтримуючи цілісність та консистенцію системи.

    Основна відмінність між композицією та агрегацією полягає в ступені залежності "частин" від "цілого". У композиції 
"частини" настільки залежні від "цілого", що не можуть існувати без нього, в той час як в агрегації "частини" мають 
більшу незалежність і можуть існувати окремо від "цілого". Вибір між цими двома типами відносин залежить від конкретної 
ситуації та того, наскільки сильною або слабкою має бути зв'язок між об'єктами у вашій моделі класів. """
