"""                                     Основи ООП в Python
                        
                        Основи ООП


    Існує декілька методологій створення програмних продуктів і Об'єктноорієнтоване програмування (ООП) по 
праву вважається однією з найефективніших.
    ☝ Спосіб організації програм, коли об'єднують дані та функціонал усередині якогось об'єкта, називають 
    об'єктноорієнтованою парадигмою програмування.
    В ООП програма розглядається як набір об'єктів, які взаємодіють між собою. Найважливіші одиниці 
програми - це класи та об’єкти. Ви пишете класи, що описують реально чинні предмети та ситуації, а потім 
створюєте об'єкти на основі цих описів. Кожен об’єкт належить до певного класу і зберігає в собі усю 
інформацію про власні дані та функціонал.
    Класи — це структура мови програмування, яка дозволяє об'єднати в рамках однієї сутності змінні різних 
типів (поля, атрибути) та функції (методи).
    Типовий приклад покемон Pikachu, це об'єкт класу Pokemon, має поля, які його характеризують: name, type, 
health. Методи attack, dodge та evolve дозволяють виконувати якісь дії та взаємодіяти з іншими об'єктами.
    Ми вже знайомі з тим, як працювати з класами у Python і неодноразово використовували їх. Річ у тім, що 
майже все у Python — це об'єкт класу.
    Покажемо найпростіший клас на наступному прикладі. """
class Person:
    pass  # Порожній блок для тіла класу

p = Person()
""" Ми створюємо новий клас за допомогою оператора class та імені класу Person. Після цього ставиться 
двокрапка і з наступного рядка слідує блок виразів, що формують тіло класу. В нашому випадку блок у нас 
порожній, на що вказує оператор pass. Далі ми створюємо об'єкт-екземпляр класу, записуючи ім'я класу з 
дужками.
    
    ☝ Існує нестрога домовленість називати клас з великої літери і, якщо назва складається з декількох 
    слів, то усі слова з великої літери без додаткових символів між ними.

    Наочною метафорою для того, щоб зрозуміти різницю між класом та об'єктом може бути форма для випічки 
печива і печиво. Клас — це форма, яка задає суть об'єкта, те, які поля він містить і як можна оперувати з 
цими полями. А об'єкт класу — це печиво, воно обов'язково буде заданої класом форми, але начинка кожного 
печива може бути різною.
    Таким чином клас — це форма для випікання, а ось готове печиво — це об'єкти класу. """
class User:
    name = 'Anonymous'
    age = 15

user1 = User()
print("Class",User)
print("user1",user1)
print("Type user1",type(user1))
print("user1.name",user1.name)
print("user1.age",user1.age)

user2 = User()
print("user2",user2)
print("Type user1",type(user2))
user2.name = "John"
user2.age = 90
print("user2.name",user2.name)
print("user2.age",user2.age)

""" Виведення:

Class <class '__main__.User'>
user1 <__main__.User object at 0x7f8c2c0cfd90>
Type user1 <class '__main__.User'>
user1.name Anonymous
user1.age 15
user2 <__main__.User object at 0x7f8c2c0cfe50>
Type user1 <class '__main__.User'>
user2.name John
user2.age 90

    В цьому прикладі ми створили два об'єкти класу User: user1 та user2. Обидва цих об'єкти належать класу 
User, бо вони мають однакову форму, але вони відмінні один від одного, бо начинка у них різна. Таким чином 
ви можете працювати з об'єктами класів user1 та user2 знаючи, що у них є поля та методи, визначені в класі 
User.

    У контексті об'єктно-орієнтованого програмування в Python, терміни "атрибут класу", "поле класу" та 
"метод класу" відносяться до різних аспектів класу, хоча іноді вони можуть використовуватися взаємозамінно.
    Атрибут класу – це змінна, яка визначена на рівні класу, а не екземпляра класу. Це означає, що вона 
спільна для всіх екземплярів цього класу. Атрибути класу використовуються для зберігання даних, які повинні 
бути однаковими для всіх об'єктів класу."""
class MyClass:
    class_attribute = "I am a class attribute" 
""" Всі екземпляри MyClass будуть мати однакове значення атрибуту class_attribute.

    Поле класу (іноді називається "атрибут екземпляра") – це змінна, яка визначена на рівні окремого 
екземпляра класу. Кожен екземпляр класу має свій власний набір полів, які можуть приймати різні значення 
для різних екземплярів. Полем може бути будь-який об'єкт Python. Зазвичай це змінна, або контейнер 
(словник, список, рядок тощо). Поля класу використовуються для зберігання даних, що специфічні для кожного 
окремого об'єкта. """
class MyClass:
    def __init__(self, value):
        """ Ініціалізуємо поле класу з переданим значенням """
        self.instance_field = value  # Поле класу

obj1 = MyClass(5)
obj2 = MyClass(10)

""" Тут об'єкти obj1 та obj2 мають різні значення поля instance_field. У obj1 значення поля instance_field 
дорівнює 5, а у obj2 значення instance_field - 10. 

    Трохи далі ми розглянемо детально різницю між полем та атрибутом.
    Метод класу — це функція, яка оперує з полями класу та/або аргументами, які передаються у метод.
Методи класу описують поведінку класу та як він взаємодіє з іншими об'єктами. Щоб метод класу міг працювати 
з іншими методами та полями класу, першим аргументом будь-якого методу завжди виступає сам об'єкт класу. 
Для першого аргументу можна використовувати будь-яку назву, яка не викликає синтаксичної помилки, однак, є 
домовленість завжди використовувати self.
    У будь-якого методу класу завжди повинен бути, принаймні, один аргумент self, це вимога синтаксису Python, 
оскільки інтерпретатор під час виклику методу обов'язково передасть першим аргументом сам об'єкт, а потім 
уже всі аргументи, які були передані під час виклику."""

class Person:
    def __init__(self, name: str, age: int):
        self.name = name
        self.age = age

    def say_name(self) -> None:
        print(f'Hi! I am {self.name} and I am {self.age} years old.')

    def set_age(self, age: int) -> None:
        self.age = age

bob = Person('Boris', 34)

bob.say_name()
bob.set_age(25)
bob.say_name()

""" Тут метод __init__() — спеціальний метод-конструктор, який автоматично виконується під час створення 
кожного нового екземпляра на базі класу Person. Ім'я методу починається і закінчується двома символами 
підкреслення. 
    Причина в тому, що так ми запобігаємо конфліктам імен стандартних методів Python та методів наших 
класів. Насправді метод __init__() є магічним методом і ми повернемося до нього у наступному модулі.
    Коли ми створюємо екземпляр Person, Python викликає метод __init__() із класу Person. Ми передаємо у 
виклик Person("Boris", 34) ім'я "Boris" та вік 34 в аргументах. Пам'ятаємо, що значення self буде передано 
автоматично, явно передавати його не потрібно.
    У цьому класу ми додали два методи класу Person: say_name та set_age. Зверніть увагу, що метод класу 
say_name не приймає параметрів, проте має self у визначенні функції. Метод виводить у консоль рядок 
привітання від користувача. Для формування цього рядку використовуються поля name та age. Метод set_age 
приймає на вхід число та записує його в поле age.

Виведення:

Hi! I am Boris and I am 34 years old.
Hi! I am Boris and I am 25 years old.


                        Різниця між полем і атрибутом класу

    У ООП поле і атрибут класу - це два терміни, які часто використовуються як синоніми. Однак між ними є 
тонка різниця.
    Змінна класу або атрибут – це змінна, яка зберігається в класі та доступ до них мають усі екземпляри 
цього класу. Змінна класу існує тільки одна, та будь-який з об'єктів, коли змінює змінну класу, змінює її 
для решти екземплярів цього ж класу.
    Змінна об'єкту або поле - це змінна, яка зберігається в об'єкті. Вона належать кожному окремому 
екземпляру класу. У цьому випадку кожен об'єкт має свою власну копію поля, тобто вона жодним чином не 
пов'язана з іншими такими ж полями в інших екземплярах.
Розглянемо наступний приклад:"""

class Person:
    count = 0

    def __init__(self, name: str):
        self.name = name
        Person.count += 1

    def how_many_persons(self):
        print(f"Кількість людей зараз {Person.count}")

first = Person('Boris')
first.how_many_persons()
second = Person('Alex')
first.how_many_persons()
# Виведення:
# Кількість людей зараз 1
# Кількість людей зараз 2

""" Тут count належить класу Person і є атрибутом класу. Його значення завжди одне й те саме для любого 
об'єкту класу. Змінна name належить об'єкту та є змінною об'єкту, і надає значення за допомогою self. Його 
значення для кожного об'єкту своє. Як бачимо з прикладу, звернення до атрибуту класу Person можна виконати 
як Person.count. До поля об'єкта name, у всіх методах цього об'єкта, ми звертаємось тільки за допомогою 
позначення self.name.
    Але якщо ми введемо змінну об'єкта з тим самим ім'ям, що й змінну класу, це зробить недоступною змінну 
класу для читання через об'єкт. """
class Person:
    count = 0

    def __init__(self):
        pass

person = Person()
print(person.count)  # 0

# В цьому прикладі ми маємо доступ до змінної класу count, а у наступному прикладі вже ні.
class Person:
    count = 0

    def __init__(self):
        self.count = 10

person = Person()
print(person.count)  # 10
# Як бачимо person.count повертає 10. Це значення поля. Але ми завжди маємо доступ до змінної класу через ім'я класу: Person.count
class Person:
    count = 0

    def __init__(self):
        self.count = 10

person = Person()
print(person.count)  # 10
print(Person.count)  # 0
""" Тут person.count повертає 10 - значення поля об'єкту person, а Person.count повертає атрибут класу зі значенням 0.
    Але головна різниця полягає не в способі оголошення, а в тому, як і де ці змінні змінюються та використовуються у класі. 
    Повернемось до прикладу: """
class Person:
    count = 0

person = Person()
person.count = 10 
print(person.count)  # 10
print(Person.count)  # 0
""" Це оголошення створює змінну класу count для класу Person. Ця змінна є загальною для всіх екземплярів класу Person.

class Person:
    count = 0

    Далі ми створюємо об'єкт person класу Person. В наступному рядку person.count = 10. У цей момент ми не змінюємо змінну класу 
count, яка була оголошена у класі Person. Натомість, ми створюємо нову змінну екземпляра count специфічну для об'єкту person.
Так, конструктора немає, але Python автоматично створює поле для об'єкту, коли ми намагаємось йому, щось присвоїти. Тепер person 
має свою власну змінну count, яка перекриває змінну класу із тим же ім'ям. Рядок print(person.count) виводить 10, оскільки ми 
звертаємось до поля count об'єкту person. А ось рядок print(Person.count) виводить 0, оскільки ми звертаємось безпосередньо до 
атрибуту count класу Person. Ця змінна класу не змінилася, оскільки ми змінили лише змінну екземпляра для конкретного екземпляра 
person.

    Отже, основна різниця полягає в області видимості та власності цих змінних. Змінні екземпляра прив'язані до конкретних 
об'єктів, тоді як змінні класу належать самому класу та спільні для всіх його екземплярів.


                        Практичний приклад

    Для кращого розуміння та візуалізації основних принципів, про які ми щойно розповідали, давайте розглянемо 
конкретний приклад. Цей приклад ілюструє використання класів та роботу з його атрибутами і методами.
    Ми створимо клас Pokemon, що ілюструє основні принципи об'єктно-орієнтованого програмування (ООП), а потім
створимо об'єкт класу Pokemon - pikachu. Клас Pokemon буде містити атрибути: name, type, і health.
    Для класу ми визначимо наступні методи:
- attack (напад) - дозволяє покемону атакувати іншого покемона.
- dodge (уклон) - дає можливість уникнути атаки.
- evolve (еволюціонувати) - дозволяє покемону еволюціонувати в іншу форму."""
class Pokemon:
    def __init__(self, name, type, health):
        self.name = name
        self.type = type
        self.health = health

    def attack(self, other_pokemon):
        print(f"{self.name} attacks {other_pokemon.name}!")

    def dodge(self):
        print(f"{self.name} dodged the attack!")

    def evolve(self, new_form):
        print(f"{self.name} is evolving into {new_form}!")
        self.name = new_form

# Створення об'єкта Pikachu
pikachu = Pokemon("Pikachu", "Electric", 100)

# Використання методів
pikachu.attack(Pokemon("Charmander", "Fire", 100))
pikachu.dodge()
pikachu.evolve("Raichu")

""" У цьому прикладі ми створили клас Pokemon та об'єкт pikachu, який може атакувати, ухилятися та еволюціонувати. 
Конструктор класу Pokemon буде викликатися, коли створюється новий екземпляр класу. Він ініціалізує екземпляр класу 
(об'єкт) з іменем name, типом покемона type, та здоров'ям health.

def __init__(self, name, type, health):
        self.name = name  # Ініціалізація атрибута імені
        self.type = type  # Ініціалізація атрибута типу
        self.health = health  # Ініціалізація атрибута здоров'я

    Далі поглянемо, що роблять методи класу Pokemon. Метод attack дозволяє об'єкту Pokemon "атакувати" інший об'єкт 
Pokemon. Він виводить повідомлення про атаку, вказуючи імена обох покемонів. Метод dodge симулює ухилення покемона 
від атаки. Виводить повідомлення, що покемон ухилився від атаки. Метод evolve дозволяє покемону еволюціонувати, 
змінюючи його ім'я на нову форму. 
    Виводить повідомлення про еволюцію та оновлює атрибут імені.
    
Створюємо екземпляр pikachu класу Pokemon, ініціалізуючи його з іменем "Pikachu", типом "Electric" та здоров'ям 100.
pikachu = Pokemon("Pikachu", "Electric", 100)

    Далі pikachu атакує новий екземпляр Pokemon з іменем "Charmander". Це демонструє, як метод attack може приймати 
інший об'єкт Pokemon як параметр.

pikachu.dodge()
Симулюємо ухилення pikachu від атаки, використовуючи метод dodge.

pikachu.evolve("Raichu")
Виконуємо еволюцію pikachu в "Raichu", використовуючи метод evolve. Це змінить значення атрибуту name об'єкта 
pikachu на "Raichu".

Виведення виконання коду:
Pikachu attacks Charmander!
Pikachu dodged the attack!
Pikachu is evolving into Raichu!

    Наш код демонструє базові принципи ООП в Python, включаючи створення класу, визначення атрибутів і методів, 
створення екземпляра класу та взаємодію з його атрибутами і методами.

Настав час розібратися за концепціями ООП. """
