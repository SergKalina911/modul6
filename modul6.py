"""                                     Основи ООП в Python
                        
                        Основи ООП


    Існує декілька методологій створення програмних продуктів і Об'єктноорієнтоване програмування (ООП) по 
праву вважається однією з найефективніших.
    ☝ Спосіб організації програм, коли об'єднують дані та функціонал усередині якогось об'єкта, називають 
    об'єктноорієнтованою парадигмою програмування.
    В ООП програма розглядається як набір об'єктів, які взаємодіють між собою. Найважливіші одиниці 
програми - це класи та об’єкти. Ви пишете класи, що описують реально чинні предмети та ситуації, а потім 
створюєте об'єкти на основі цих описів. Кожен об’єкт належить до певного класу і зберігає в собі усю 
інформацію про власні дані та функціонал.
    Класи — це структура мови програмування, яка дозволяє об'єднати в рамках однієї сутності змінні різних 
типів (поля, атрибути) та функції (методи).
    Типовий приклад покемон Pikachu, це об'єкт класу Pokemon, має поля, які його характеризують: name, type, 
health. Методи attack, dodge та evolve дозволяють виконувати якісь дії та взаємодіяти з іншими об'єктами.
    Ми вже знайомі з тим, як працювати з класами у Python і неодноразово використовували їх. Річ у тім, що 
майже все у Python — це об'єкт класу.
    Покажемо найпростіший клас на наступному прикладі. """
class Person:
    pass  # Порожній блок для тіла класу

p = Person()
""" Ми створюємо новий клас за допомогою оператора class та імені класу Person. Після цього ставиться 
двокрапка і з наступного рядка слідує блок виразів, що формують тіло класу. В нашому випадку блок у нас 
порожній, на що вказує оператор pass. Далі ми створюємо об'єкт-екземпляр класу, записуючи ім'я класу з 
дужками.
    
    ☝ Існує нестрога домовленість називати клас з великої літери і, якщо назва складається з декількох 
    слів, то усі слова з великої літери без додаткових символів між ними.

    Наочною метафорою для того, щоб зрозуміти різницю між класом та об'єктом може бути форма для випічки 
печива і печиво. Клас — це форма, яка задає суть об'єкта, те, які поля він містить і як можна оперувати з 
цими полями. А об'єкт класу — це печиво, воно обов'язково буде заданої класом форми, але начинка кожного 
печива може бути різною.
    Таким чином клас — це форма для випікання, а ось готове печиво — це об'єкти класу. """
class User:
    name = 'Anonymous'
    age = 15

user1 = User()
print("Class",User)
print("user1",user1)
print("Type user1",type(user1))
print("user1.name",user1.name)
print("user1.age",user1.age)

user2 = User()
print("user2",user2)
print("Type user1",type(user2))
user2.name = "John"
user2.age = 90
print("user2.name",user2.name)
print("user2.age",user2.age)

""" Виведення:

Class <class '__main__.User'>
user1 <__main__.User object at 0x7f8c2c0cfd90>
Type user1 <class '__main__.User'>
user1.name Anonymous
user1.age 15
user2 <__main__.User object at 0x7f8c2c0cfe50>
Type user1 <class '__main__.User'>
user2.name John
user2.age 90

    В цьому прикладі ми створили два об'єкти класу User: user1 та user2. Обидва цих об'єкти належать класу 
User, бо вони мають однакову форму, але вони відмінні один від одного, бо начинка у них різна. Таким чином 
ви можете працювати з об'єктами класів user1 та user2 знаючи, що у них є поля та методи, визначені в класі 
User.

    У контексті об'єктно-орієнтованого програмування в Python, терміни "атрибут класу", "поле класу" та 
"метод класу" відносяться до різних аспектів класу, хоча іноді вони можуть використовуватися взаємозамінно.
    Атрибут класу – це змінна, яка визначена на рівні класу, а не екземпляра класу. Це означає, що вона 
спільна для всіх екземплярів цього класу. Атрибути класу використовуються для зберігання даних, які повинні 
бути однаковими для всіх об'єктів класу."""
class MyClass:
    class_attribute = "I am a class attribute" 
""" Всі екземпляри MyClass будуть мати однакове значення атрибуту class_attribute.

    Поле класу (іноді називається "атрибут екземпляра") – це змінна, яка визначена на рівні окремого 
екземпляра класу. Кожен екземпляр класу має свій власний набір полів, які можуть приймати різні значення 
для різних екземплярів. Полем може бути будь-який об'єкт Python. Зазвичай це змінна, або контейнер 
(словник, список, рядок тощо). Поля класу використовуються для зберігання даних, що специфічні для кожного 
окремого об'єкта. """
class MyClass:
    def __init__(self, value):
        """ Ініціалізуємо поле класу з переданим значенням """
        self.instance_field = value  # Поле класу

obj1 = MyClass(5)
obj2 = MyClass(10)

""" Тут об'єкти obj1 та obj2 мають різні значення поля instance_field. У obj1 значення поля instance_field 
дорівнює 5, а у obj2 значення instance_field - 10. 

    Трохи далі ми розглянемо детально різницю між полем та атрибутом.
    Метод класу — це функція, яка оперує з полями класу та/або аргументами, які передаються у метод.
Методи класу описують поведінку класу та як він взаємодіє з іншими об'єктами. Щоб метод класу міг працювати 
з іншими методами та полями класу, першим аргументом будь-якого методу завжди виступає сам об'єкт класу. 
Для першого аргументу можна використовувати будь-яку назву, яка не викликає синтаксичної помилки, однак, є 
домовленість завжди використовувати self.
    У будь-якого методу класу завжди повинен бути, принаймні, один аргумент self, це вимога синтаксису Python, 
оскільки інтерпретатор під час виклику методу обов'язково передасть першим аргументом сам об'єкт, а потім 
уже всі аргументи, які були передані під час виклику."""

class Person:
    def __init__(self, name: str, age: int):
        self.name = name
        self.age = age

    def say_name(self) -> None:
        print(f'Hi! I am {self.name} and I am {self.age} years old.')

    def set_age(self, age: int) -> None:
        self.age = age

bob = Person('Boris', 34)

bob.say_name()
bob.set_age(25)
bob.say_name()

""" Тут метод __init__() — спеціальний метод-конструктор, який автоматично виконується під час створення 
кожного нового екземпляра на базі класу Person. Ім'я методу починається і закінчується двома символами 
підкреслення. 
    Причина в тому, що так ми запобігаємо конфліктам імен стандартних методів Python та методів наших 
класів. Насправді метод __init__() є магічним методом і ми повернемося до нього у наступному модулі.
    Коли ми створюємо екземпляр Person, Python викликає метод __init__() із класу Person. Ми передаємо у 
виклик Person("Boris", 34) ім'я "Boris" та вік 34 в аргументах. Пам'ятаємо, що значення self буде передано 
автоматично, явно передавати його не потрібно.
    У цьому класу ми додали два методи класу Person: say_name та set_age. Зверніть увагу, що метод класу 
say_name не приймає параметрів, проте має self у визначенні функції. Метод виводить у консоль рядок 
привітання від користувача. Для формування цього рядку використовуються поля name та age. Метод set_age 
приймає на вхід число та записує його в поле age.

Виведення:

Hi! I am Boris and I am 34 years old.
Hi! I am Boris and I am 25 years old.


                        Різниця між полем і атрибутом класу

    У ООП поле і атрибут класу - це два терміни, які часто використовуються як синоніми. Однак між ними є 
тонка різниця.
    Змінна класу або атрибут – це змінна, яка зберігається в класі та доступ до них мають усі екземпляри 
цього класу. Змінна класу існує тільки одна, та будь-який з об'єктів, коли змінює змінну класу, змінює її 
для решти екземплярів цього ж класу.
    Змінна об'єкту або поле - це змінна, яка зберігається в об'єкті. Вона належать кожному окремому 
екземпляру класу. У цьому випадку кожен об'єкт має свою власну копію поля, тобто вона жодним чином не 
пов'язана з іншими такими ж полями в інших екземплярах.
Розглянемо наступний приклад:"""

class Person:
    count = 0

    def __init__(self, name: str):
        self.name = name
        Person.count += 1

    def how_many_persons(self):
        print(f"Кількість людей зараз {Person.count}")

first = Person('Boris')
first.how_many_persons()
second = Person('Alex')
first.how_many_persons()
# Виведення:
# Кількість людей зараз 1
# Кількість людей зараз 2

""" Тут count належить класу Person і є атрибутом класу. Його значення завжди одне й те саме для любого 
об'єкту класу. Змінна name належить об'єкту та є змінною об'єкту, і надає значення за допомогою self. Його 
значення для кожного об'єкту своє. Як бачимо з прикладу, звернення до атрибуту класу Person можна виконати 
як Person.count. До поля об'єкта name, у всіх методах цього об'єкта, ми звертаємось тільки за допомогою 
позначення self.name.
    Але якщо ми введемо змінну об'єкта з тим самим ім'ям, що й змінну класу, це зробить недоступною змінну 
класу для читання через об'єкт. """
class Person:
    count = 0

    def __init__(self):
        pass

person = Person()
print(person.count)  # 0

# В цьому прикладі ми маємо доступ до змінної класу count, а у наступному прикладі вже ні.
class Person:
    count = 0

    def __init__(self):
        self.count = 10

person = Person()
print(person.count)  # 10
# Як бачимо person.count повертає 10. Це значення поля. Але ми завжди маємо доступ до змінної класу через ім'я класу: Person.count
class Person:
    count = 0

    def __init__(self):
        self.count = 10

person = Person()
print(person.count)  # 10
print(Person.count)  # 0
""" Тут person.count повертає 10 - значення поля об'єкту person, а Person.count повертає атрибут класу зі значенням 0.
    Але головна різниця полягає не в способі оголошення, а в тому, як і де ці змінні змінюються та використовуються у класі. 
    Повернемось до прикладу: """
class Person:
    count = 0

person = Person()
person.count = 10 
print(person.count)  # 10
print(Person.count)  # 0
""" Це оголошення створює змінну класу count для класу Person. Ця змінна є загальною для всіх екземплярів класу Person.

class Person:
    count = 0

    Далі ми створюємо об'єкт person класу Person. В наступному рядку person.count = 10. У цей момент ми не змінюємо змінну класу 
count, яка була оголошена у класі Person. Натомість, ми створюємо нову змінну екземпляра count специфічну для об'єкту person.
Так, конструктора немає, але Python автоматично створює поле для об'єкту, коли ми намагаємось йому, щось присвоїти. Тепер person 
має свою власну змінну count, яка перекриває змінну класу із тим же ім'ям. Рядок print(person.count) виводить 10, оскільки ми 
звертаємось до поля count об'єкту person. А ось рядок print(Person.count) виводить 0, оскільки ми звертаємось безпосередньо до 
атрибуту count класу Person. Ця змінна класу не змінилася, оскільки ми змінили лише змінну екземпляра для конкретного екземпляра 
person.

    Отже, основна різниця полягає в області видимості та власності цих змінних. Змінні екземпляра прив'язані до конкретних 
об'єктів, тоді як змінні класу належать самому класу та спільні для всіх його екземплярів.


                        Практичний приклад

    Для кращого розуміння та візуалізації основних принципів, про які ми щойно розповідали, давайте розглянемо 
конкретний приклад. Цей приклад ілюструє використання класів та роботу з його атрибутами і методами.
    Ми створимо клас Pokemon, що ілюструє основні принципи об'єктно-орієнтованого програмування (ООП), а потім
створимо об'єкт класу Pokemon - pikachu. Клас Pokemon буде містити атрибути: name, type, і health.
    Для класу ми визначимо наступні методи:
- attack (напад) - дозволяє покемону атакувати іншого покемона.
- dodge (уклон) - дає можливість уникнути атаки.
- evolve (еволюціонувати) - дозволяє покемону еволюціонувати в іншу форму."""
class Pokemon:
    def __init__(self, name, type, health):
        self.name = name
        self.type = type
        self.health = health

    def attack(self, other_pokemon):
        print(f"{self.name} attacks {other_pokemon.name}!")

    def dodge(self):
        print(f"{self.name} dodged the attack!")

    def evolve(self, new_form):
        print(f"{self.name} is evolving into {new_form}!")
        self.name = new_form

# Створення об'єкта Pikachu
pikachu = Pokemon("Pikachu", "Electric", 100)

# Використання методів
pikachu.attack(Pokemon("Charmander", "Fire", 100))
pikachu.dodge()
pikachu.evolve("Raichu")

""" У цьому прикладі ми створили клас Pokemon та об'єкт pikachu, який може атакувати, ухилятися та еволюціонувати. 
Конструктор класу Pokemon буде викликатися, коли створюється новий екземпляр класу. Він ініціалізує екземпляр класу 
(об'єкт) з іменем name, типом покемона type, та здоров'ям health.

def __init__(self, name, type, health):
        self.name = name  # Ініціалізація атрибута імені
        self.type = type  # Ініціалізація атрибута типу
        self.health = health  # Ініціалізація атрибута здоров'я

    Далі поглянемо, що роблять методи класу Pokemon. Метод attack дозволяє об'єкту Pokemon "атакувати" інший об'єкт 
Pokemon. Він виводить повідомлення про атаку, вказуючи імена обох покемонів. Метод dodge симулює ухилення покемона 
від атаки. Виводить повідомлення, що покемон ухилився від атаки. Метод evolve дозволяє покемону еволюціонувати, 
змінюючи його ім'я на нову форму. 
    Виводить повідомлення про еволюцію та оновлює атрибут імені.
    
Створюємо екземпляр pikachu класу Pokemon, ініціалізуючи його з іменем "Pikachu", типом "Electric" та здоров'ям 100.
pikachu = Pokemon("Pikachu", "Electric", 100)

    Далі pikachu атакує новий екземпляр Pokemon з іменем "Charmander". Це демонструє, як метод attack може приймати 
інший об'єкт Pokemon як параметр.

pikachu.dodge()
Симулюємо ухилення pikachu від атаки, використовуючи метод dodge.

pikachu.evolve("Raichu")
Виконуємо еволюцію pikachu в "Raichu", використовуючи метод evolve. Це змінить значення атрибуту name об'єкта 
pikachu на "Raichu".

Виведення виконання коду:
Pikachu attacks Charmander!
Pikachu dodged the attack!
Pikachu is evolving into Raichu!

    Наш код демонструє базові принципи ООП в Python, включаючи створення класу, визначення атрибутів і методів, 
створення екземпляра класу та взаємодію з його атрибутами і методами.

Настав час розібратися за концепціями ООП. 

                        Інкапсуляція
                        
    ООП має чотири основні концепції, які відрізняють його від інших методологій програмування:

                        Абстракція
                        Інкапсуляція
                        Наслідування
                        Поліморфізм

    З чотирьох концепцій ми розберемо три останні, окрім абстракції. Це більш просунута категорія, і створення 
абстрактних класів ми не розглядатимемо на цьому блоці навчання. Коротко тільки зауважимо, що абстракція - це модель 
якогось об'єкта або явища з реального світу, що відкидає незначні деталі, які не грають істотну роль в контексті 
розгляду концепції ООП.

    Інкапсуляція в програмуванні, зокрема в об'єктно-орієнтованому програмуванні (ООП), є одним із ключових принципів, 
який полягає в приховуванні внутрішньої структури класу та захисті його даних від прямого доступу ззовні. Цей принцип 
дозволяє обмежити доступ до певних компонентів класу (полів і методів), забезпечуючи контроль над тим, як ці дані 
використовуються та змінюються.
    За допомогою атрибутів та методів класу ми виконуємо інкапсуляцію — приховуємо деталі реалізації під інтерфейсом 
класу.
    Розглянемо наступний код:"""

class Person:
    def __init__(self, name: str, age: int):
        self.name = name
        self.age = age

    def greeting(self) -> str:
        return f"Hi {self.name}"

p = Person("Boris", 34)

""" Клас Person має два поля name та age та метод greeting, до яких можна вільно доступатися з будь-якого місця у 
програмі. В Python вони не мають спеціального префіксу. Такі методи та поля називають публічними (public), 
тобто вони доступні для прямого читання та зміни ззовні класу.
    Загалом інкапсуляція в ООП реалізується через використання публічних (public), захищених (protected) і приватних 
(private) атрибутів та методів.

Public - елемент доступний з будь-якого місця в програмі.
Protected - елемент доступний з класу, в якому він оголошений, а також з класів-похідних.
Private - елемент доступний лише з класу, в якому він оголошений.

    Але інкапсуляція в Python має декілька особливостей, які можуть сприйматися як проблеми або обмеження, особливо 
якщо порівнювати з іншими мовами програмування, які мають строгіші механізми доступу.

                        
                        Захищені (Protected) атрибути та методи.

    Вони позначаються одним підкресленням _ на початку імені. Це лише конвенція, і захищені атрибути все ще можуть 
бути доступні ззовні, але це вважається поганою практикою змінювати їх ззовні."""
class Person:
    def __init__(self, name: str, age: int, is_active: bool):
        self.name = name
        self.age = age
        self._is_active = is_active

    def greeting(self):
        return f"Hi {self.name}"

p = Person("Boris", 34, True)
print(p.name, p.age, p._is_active)
print(p.greeting())
# Виведення:
# Boris 34 True
# Hi Boris

""" Поле _is_active має провідне нижнє підкреслення, щоб показати, що воно призначене для того, щоб бути захищеним. 
Поганою практикою в цьому контексті вважається доступ або зміна захищених атрибутів класу p._is_active ззовні цього 
класу або ззовні його нащадків. Що нами і зроблено але тільки в рамках демонстрації!
    Коли ви взаємодієте з об'єктом, ідея полягає в тому, щоб використовувати його публічний інтерфейс (публічні 
методи та атрибути), а не безпосередньо звертатися до його внутрішньої реалізації або захищених частин. Отже, що хоча 
технічно можливо отримати доступ до цих атрибутів ззовні, це вважається порушенням принципів інкапсуляції.
    Правильним підходом є забезпечення доступу до захищених атрибутів через публічні методи, які можуть включати 
додаткову логіку обробки або перевірки, тим самим підтримуючи безпеку та цілісність даних всередині класу.
    Якщо ми хочемо взаємодіяти з захищеними полями об'єкту ззовні, необхідно впровадити правильний підхід до 
інкапсуляції у класі Person та слід використовувати методи для взаємодії з такими атрибутами об'єкту """
class Person:
    def __init__(self, name: str, age: int, is_active: bool):
        self.name = name
        self.age = age
        self._is_active = is_active

    def greeting(self):
        return f"Hi {self.name}"
    
    def is_active(self):
        return self._is_active

    def set_active(self, active: bool):
        self._is_active = active

p = Person("Boris", 34, True)
print(p.name, p.age, p.is_active())
print(p.greeting())
""" Ми додали метод is_active, щоб отримати доступ для читання захищеного атрибута _is_active та метод set_active 
для зміни значення захищеного атрибута _is_active 

                        Приватні (Private) атрибути та методи

    В Python не існує справжньої приватності для атрибутів класів, як це реалізовано, наприклад, у Java. Python 
використовує так зване "перетворення імен" для забезпечення цього рівня інкапсуляції. Атрибути, що вважаються 
приватними позначаються двома підкресленнями __ і не можуть бути доступні безпосередньо ззовні класу."""

class Person:
    def __init__(self, name: str, age: int, is_active: bool, is_admin: bool):
        self.name = name
        self.age = age
        self._is_active = is_active
        self.__is_admin = is_admin

    def greeting(self):
        return f"Hi {self.name}"

    def is_active(self):
        return self._is_active

    def set_active(self, active: bool):
        self._is_active = active

p = Person("Boris", 34, True, False)
# print(p.__is_admin)

""" Виведення:
---------------------------------------------------------------------------
AttributeError                            Traceback (most recent call last)
Cell In[6], line 13
      9         return f"Hi {self.name}"
     12 p = Person("Boris", 34, True, False)
---> 13 print(p.__is_admin)

AttributeError: 'Person' object has no attribute '__is_admin'

    Як видно з цього прикладу, доступу за допомогою p.__is_admin немає.
    Насправді було лише змінене ім'я поля, щоб запобігти випадковому доступу до нього, але воно все одно доступно
ззовні класу. Змінене ім'я формується як знак підкреслювання, ім'я класу та ім'я змінної. """

class Person:
    def __init__(self, name: str, age: int, is_active: bool, is_admin: bool):
        self.name = name
        self.age = age
        self._is_active = is_active
        self.__is_admin = is_admin

    def greeting(self):
        return f"Hi {self.name}"

    def is_active(self):
        return self._is_active

    def set_active(self, active: bool):
        self._is_active = active

p = Person("Boris", 34, True, False)
print(p._Person__is_admin)
# Виведення:False

""" Тож можна, за бажанням, отримати доступ до поля __is_admin через вираз p._Person__is_admin, що загалом нічого не захищає.
Щоб реалізувати методи доступу до приватного поля __is_admin у класі Person, ми можемо використати той самий підхід,
що і до захищеного поля _is_active
"""
class Person:
    def __init__(self, name: str, age: int, is_active: bool, is_admin: bool):
        self.name = name
        self.age = age
        self._is_active = is_active
        self.__is_admin = is_admin

    def greeting(self):
        return f"Hi {self.name}"

    def is_active(self):
        return self._is_active

    def set_active(self, active: bool):
        self._is_active = active

    def get_is_admin(self):
        return self.__is_admin

    def set_is_admin(self, is_admin: bool):
        # Тут можна додати будь-яку логіку перевірки або обробки
        self.__is_admin = is_admin

        
p = Person("Boris", 34, True, False)
print(p.get_is_admin())
p.set_is_admin(True)
print(p.get_is_admin())

""" Виведення:

False
True

    У цьому прикладі, метод get_is_admin дозволяє отримати значення поля __is_admin, а метод set_is_admin дозволяє 
його змінити. Це забезпечує контрольований доступ до приватного поля, дозволяючи внести необхідну логіку перевірки 
або обробки при зміні значення.

    Як бачимо багато аспектів інкапсуляції в Python базуються на конвенціях, а не на строгих правилах мови. Через 
відкритий характер Python, дуже легко обійти інкапсуляцію, отримуючи доступ до "захищених" або "приватних" атрибутів 
класу ззовні. Це може призвести до порушення інтегральності даних або неочікуваної поведінки об'єктів.

    Ефективна інкапсуляція в Python значною мірою залежить від дисципліни та узгодженості розробників. Оскільки багато 
обмежень доступу є лише конвенціями, то строге дотримання цих конвенцій є важливим для підтримки інкапсуляції. 

                        Наслідування

    Основна сила об'єктно-орієнтованого програмування полягає саме в можливості наслідування класів. Наслідування дає 
можливість створювати нові класи, що містять атрибути батьківських класів.
    Наслідування - це механізм ООП, який дозволяє одному класу переймати властивості та методи іншого класу. У Python 
це робиться шляхом оголошення класу, який "наслідується" від іншого класу.
    Базовий або батьківський клас (superclass) це клас, від якого наслідуються властивості та методи.
    Похідний або дочірній клас (subclass) це клас, який наслідує властивості та методи від базового класу.
    Розглянемо приклад де буде базовий клас Animal. Він може мати загальні властивості для всіх тварин, наприклад, 
nickname (ім'я), age (вік) і метод make_sound() (видавати звук). А також похідні класи Cat, Dog та Cow, які наслідують 
властивості та методи від класу Animal, але також можуть мати свої унікальні методи або перевизначені методи базового класу."""
class Animal:
    def __init__(self, nickname: str, age: int):
        self.nickname = nickname
        self.age = age

    def make_sound(self):
        pass

class Cat(Animal):
    def make_sound(self) -> str:
        return "Meow"

class Dog(Animal):
    def make_sound(self) -> str:
        return "Woof"

class Cow(Animal):  
    def make_sound(self):
        return "Moo"

my_cat = Cat("Simon", 4)
my_dog = Dog("Rex", 5)
my_cow = Cow("Bessie", 3)

print(my_cat.make_sound())  # Виведе "Meow"
print(my_dog.make_sound())  # Виведе "Woof"
print(my_cow.make_sound())  # Виведе "Moo"
""" У цьому прикладі клас Cat наслідує властивість nickname та метод make_sound() від класу Animal. Однак, в класі Cat
метод make_sound() перевизначений, щоб повертати рядок "Meow". У класі Dog, метод make_sound() також перевизначений, щоб 
повертати "Woof", що є характерним звуком для собак. У класі Cow, метод make_sound() перевизначений, щоб повертати "Moo".
    Класи Cat, Dog, і Cow є похідними класами, які наслідують властивості та методи від базового класу Animal. Це означає, 
що вони автоматично отримують властивості nickname, age і можуть використовувати метод make_sound().
    Кожен екземпляр тварини має своє ім'я, вік та може видавати властивий для свого виду звук. Це демонструє, як наслідування 
дозволяє нам писати код, який є відновлюваним та легким для розширення.

    У похідних класах можна визначати власні конструктори. Якщо ми хочемо зберегти поведінку базового класу і додати нові 
властивості, ми можемо використовувати конструкцію super() для виклику конструктора базового класу.
    Розширимо наш приклад, додавши унікальну властивість до класу Dog - поле breed (порода). """
class Dog(Animal):
    def __init__(self, nickname: str, age: int, breed: str):
        super().__init__(nickname, age)  # Викликаємо конструктор базового класу
        self.breed = breed  # Додаємо нову властивість
  
    def make_sound(self) -> str:
        return "Woof"
my_dog = Dog("Rex", 5, "Labrador")
print(my_dog.nickname)  # Виведе "Rex"
print(my_dog.age)      # Виведе 5
print(my_dog.breed)    # Виведе "Labrador"
print(my_dog.make_sound())  # Виведе "Woof"

""" Tут, super().__init__(nickname, age) викликає конструктор Animal, щоб встановити ім'я та вік собаки, а self.breed = breed 
встановлює породу собаки.
    Конструкція super() використовується для забезпечення того, що методи базового класу можуть бути викликані з похідного класу, 
особливо коли ці методи перевизначаються. Це дуже корисно, коли ми хочемо розширити або змінити поведінку базового класу, не 
повністю переписуючи його.
    Отже, якщо ми захочемо додати функціонал у всі дочірні для Animal класи, то для цього можна додати потрібні атрибути та методи 
в Animal і вони автоматично з'являться в класах Cat, Dog, і Cow. Як ми і зробили спочатку додавши атрибути name та age в Animal 
які присутні в цих класах. Якщо ж потрібно додати особливу поведінку для об'єктів собак, то можна додати або змінити атрибути 
класу Dog. Наприклад, додамо метод chase_tail() до класу Dog. 
class Dog(Animal):
    def __init__(self, name, breed):
        super().__init__(name)  # Викликаємо конструктор базового класу
        self.breed = breed  # Додаємо нову властивість

    def make_sound(self) -> str:
        return "Woof"

    def chase_tail(self) -> str:
        return f"{self.name} is chasing its tail!"

Тепер клас Dog має унікальний метод, який не є частиною класу Animal і створення екземпляру собаки виглядає наступним чином:
my_dog = Dog("Rex", 5, "Golden Retriever")
print(my_dog.make_sound())  # Виведе "Woof"
print(my_dog.chase_tail())  # Виведе "Rex is chasing its tail!"
Собаки тепер в нас ганяються за своїм хвостом.

Повний код виглядатиме тепер так:
"""
class Animal:
    def __init__(self, nickname: str, age: int):
        self.nickname = nickname
        self.age = age

    def make_sound(self):
        pass

class Cat(Animal):
    def make_sound(self) -> str:
        return "Meow"

class Dog(Animal):

    def __init__(self, nickname: str, age: int, breed: str):
        super().__init__(nickname, age)  # Викликаємо конструктор базового класу
        self.breed = breed  # Додаємо нову властивість

    def make_sound(self) -> str:
        return "Woof"

    def chase_tail(self) -> str:
        return f"{self.nickname} is chasing its tail!"

class Cow(Animal):
    def make_sound(self):
        return "Moo"

my_cat = Cat("Simon", 4)
my_cow = Cow("Bessie", 3)

print(my_cat.make_sound())  # Виведе "Meow"
print(my_cow.make_sound())  # Виведе "Moo"

my_dog = Dog("Rex", 5, "Golden Retriever")
print(my_dog.make_sound())  # Виведе "Woof"
print(my_dog.chase_tail())  # Виведе "Rex is chasing its tail!"
""" Таким чином у коді повинно бути лише одне місце, де визначено поведінку об'єкта. І якщо нам потрібно отримати інший об'єкт, 
який має цю поведінку і якісь свої особливості, ми можемо наслідуватись від класу з потрібними нам спільними атрибутами та 
додати унікальні. Цей підхід дозволяє писати менше коду та структурувати дані, створюючи моделі реальних об'єктів з їх 
характеристиками (полями) та поведінкою (методами). 

                        Багаторівневе наслідування та Method Resolution Order (MRO).

    Розглянемо більш складні аспекти наслідування в ООП, та почнемо з багаторівневого наслідування.
    Багаторівневе наслідування - це коли клас наслідує від іншого класу, який вже є похідним класом. Це створює "ланцюжок" 
наслідування, де можливості передаються через декілька рівнів.
    Уявімо, що ми маємо клас Bird і хочемо створити клас Parrot, який наслідує від Bird. Але потім ми вирішуємо створити 
новий клас TalkingParrot, який наслідується вже від Parrot."""
class Animal:
    def __init__(self, nickname: str, age: int):
        self.nickname = nickname
        self.age = age

    def make_sound(self):
        pass

class Bird(Animal):
    def make_sound(self):
        return "Chirp"

class Parrot(Bird):
    def can_fly(self):
        return True

class TalkingParrot(Parrot):
    def say_phrase(self, phrase):
        return f"The parrot says: '{phrase}'"

my_parrot = TalkingParrot("Alice", 2)
print(my_parrot.make_sound())
print(my_parrot.can_fly())
print(my_parrot.say_phrase("Hello, World!"))
# Виведення:
# Chirp
# True
# The parrot says: 'Hello, World!'

""" У цьому прикладі, TalkingParrot наслідується від Parrot, який, у свою чергу, наслідується від Bird. Це дозволяє 
TalkingParrot використовувати методи і властивості всіх своїх предків від Animal до Parrot. 

    Як ми бачимо наслідування дуже потужний інструмент. Але наслідуватися можна не тільки від одного класу, а можна 
одразу від кількох. Таким чином можна отримувати об'єкти, що поєднують у собі властивості багатьох класів. Тут повинно 
виникнути питання, а що буде, якщо кілька класів мають атрибути з однаковим ім'ям?
    Для відповіді на це питання потрібно зрозуміти, як Python шукає атрибути (поля або методи) в об'єктах. MRO (Method 
Resolution Order) в Python, визначає порядок, за яким класи будуть переглядатися під час пошуку методів.
    Python визначає MRO за допомогою алгоритму лінійного упорядкування. Основна ідея цього алгоритму полягає в тому, щоб 
зберегти порядок визначення класів та водночас забезпечити, щоб базові класи були перевірені після всіх їхніх похідних класів.
    MRO у Python працює наступним чином:
        1. Шукає атрибут серед атрибутів самого класу. Саме завдяки цьому ви можете "перевизначати" батьківські атрибути.
        2. Шукає атрибут у першого з батьків (той, що вказаний першим у списку батьків).
        3. Шукає атрибут у наступного батька у списку батьків, доки такі є.
        4. Шукає атрибут у батьках першого батька.
        5. Повторює пункт 4 для всіх батьків.
        6. Викликає виняток, що атрибут не знайдено.
    Пошуки закінчуються, як тільки атрибут знайдено.

    Ви можете переглянути MRO для будь-якого класу використовуючи метод mro() або атрибут __mro__. Наприклад:"""
class A:
    pass

class B(A):
    pass

class C(A):
    pass

class D(B, C):
    pass

print(D.mro())  # Виведе порядок розв'язання методів для класу D
""" Зверніть увагу що виклик відбувається на самому класі, а не екземплярі класу. У цьому прикладі виведення буде наступним:

[<class '__main__.D'>, <class '__main__.B'>, <class '__main__.C'>, <class '__main__.A'>, <class 'object'>]

    Це порядок MRO для класу D який означає, що Python спочатку шукатиме методи в D, потім у B, за ними в C, потім в A, і, 
нарешті, в вбудованому базовому класі object, який є предком всіх класів.

    Навіщо нам це знати? Розробники можуть чітко зрозуміти, звідки буде взято метод або атрибут об'єкта.
    Давайте розберемо це на більш наочному прикладі. Де буде брати значення для поля name екземпляр класу C? """
class A:
    name = "Я клас A"

class B:
    name = "Я клас B"
    property = "Я знаходжусь в класі B"

class C(A, B):
    property = "Я знаходжусь в класі C"

c = C()
print(c.name)
print(c.property)
# """ Виведення:
# Я клас A
# Я знаходжусь в класі C
""" З цього прикладу видно, що у класі C поле name береться з A класу. Якщо ж в цьому самому прикладі змінити список 
батьків з C(A, B) на C(B, A), то отримаємо: """
class A:
    name = "Я клас A"

class B:
    name = "Я клас B"
    property = "Я знаходжусь в класі B"

class C(B, A):
    property = "Я знаходжусь в класі C"

c = C()
print(c.name)
print(c.property)
# Виведення:
# Я клас B
# Я знаходжусь в класі C
""" Тепер у класі C поле name береться з B класу.
    Розуміння MRO в Python є ключовим для ефективної роботи з класами, особливо коли використовується багаторазове 
наслідування, оскільки це допомагає розробникам правильно організувати свої класи та очікувати, звідки будуть взяті 
методи та атрибути. """
